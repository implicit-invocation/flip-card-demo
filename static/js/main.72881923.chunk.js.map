{"version":3,"sources":["game/init.js","index.js"],"names":["shuffle","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","init","gl","width","height","canvas","a","async","targetRatio","worldHeight","worldWidth","config","background","loadTexture","bg","camera","createOrthoCamera","batch","createBatch","loadAtlas","atlasUrl","genMipmaps","atlas","getPages","texture","setFilter","LINEAR","inputHandler","InputHandler","types","states","solved","i","push","offsetY","size","drawWidth","margin","pad","offsetX","displayPos","offsets","scales","row","x","column","y","flipped","flipBackTime","flipBack","flyAwayTime","flyAway","flip","index","b","moveCount","click","screenClickPos","worldClickPos","devicePixelRatio","window","addEventListener","unprojectVector2","dPos","running","stop","cleanup","finishGame","alert","onFinish","processEffect","delta","max","undefined","currentOffset","currentState","currentScale","min","shadow","findRegion","items","findRegions","back","backgroundColor","clearR","clearG","clearB","clearColor","render","clear","COLOR_BUFFER_BIT","setProjection","combined","begin","draw","type","scale","off","abs","end","finish","lastUpdate","Date","now","loop","requestAnimationFrame","setOnFinish","handler","document","getElementById","displayWidth","clientWidth","displayHeight","clientHeight","resize","getContext","antialias","startNewGame"],"mappings":"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","file":"static/js/main.72881923.chunk.js","sourcesContent":["import createOrthoCamera from \"gdxjs/lib/orthoCamera\";\nimport createBatch from \"gdxjs/lib/createBatch\";\nimport loadAtlas from \"gdxjs/lib/loadAtlas\";\nimport InputHandler from \"gdxjs/lib/InputHandler\";\n\nimport config from \"../configs/shopee.json\";\nimport loadTexture from \"gdxjs/lib/loadTexture\";\n\nfunction shuffle(array) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  while (0 !== currentIndex) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n}\n\nconst init = async (gl, width, height, canvas) => {\n  const targetRatio = 812 / 375;\n  let worldWidth, worldHeight;\n\n  if (width < height) {\n    worldWidth = 300;\n    worldHeight = (worldWidth / width) * height;\n  } else {\n    worldHeight = 300 * targetRatio;\n    worldWidth = (worldHeight / height) * width;\n  }\n\n  let bg;\n\n  if (config.background) {\n    bg = await loadTexture(gl, config.background);\n  }\n\n  const camera = createOrthoCamera(worldWidth, worldHeight, width, height);\n  const batch = createBatch(gl);\n  const atlas = await loadAtlas(gl, config.atlasUrl, {\n    genMipmaps: true\n  });\n  for (let page of atlas.getPages()) {\n    page.texture.setFilter(gl.LINEAR, gl.LINEAR, true);\n  }\n\n  const inputHandler = new InputHandler(canvas);\n\n  const types = [];\n  const states = [];\n  const solved = [];\n\n  for (let i = 0; i < 12; i++) {\n    types.push(i % 6);\n    states.push(false);\n    solved.push(false);\n  }\n  shuffle(types);\n\n  let margin, pad, size, offsetY, offsetX, drawWidth;\n\n  if (worldWidth < worldHeight / targetRatio) {\n    drawWidth = worldWidth;\n    margin = drawWidth * 0.05;\n    pad = 10;\n    size = (drawWidth - 2 * margin - 2 * pad) / 3;\n    offsetY = (worldHeight - size * 4 - pad * 3) / 2;\n    offsetX = 0;\n  } else {\n    drawWidth = worldHeight / targetRatio;\n    margin = drawWidth * 0.05;\n    pad = 10;\n    size = (drawWidth - 2 * margin - 2 * pad) / 3;\n    offsetY = (worldHeight - size * 4 - pad * 3) / 2;\n    offsetX = (worldWidth - drawWidth) / 2;\n  }\n\n  const shadowDistance = 3;\n\n  const displayPos = [];\n  const offsets = [];\n  const scales = [];\n\n  for (let i = 0; i < states.length; i++) {\n    let row = Math.floor(i / 3);\n    let column = i % 3;\n\n    let x = offsetX + column * size + margin + column * pad;\n    let y = offsetY + row * size + row * pad;\n    displayPos.push({ x, y, width: size, height: size });\n    scales.push(-1);\n    offsets.push(0);\n  }\n\n  const flipped = [];\n  let flipBackTime = 0;\n  let flipBack = false;\n  let flyAwayTime = 0;\n  let flyAway = false;\n  const flip = index => {\n    states[index] = !states[index];\n    flipped.push(index);\n    if (flipped.length === 2) {\n      const [a, b] = flipped;\n      if (types[a] === types[b]) {\n        flyAwayTime = 0.5;\n        flyAway = true;\n      } else {\n        flipBackTime = 0.5;\n        flipBack = true;\n      }\n    }\n  };\n\n  let moveCount = 0;\n\n  const click = index => {\n    if (scales[index] === -1 && !solved[index] && flipped.length < 2) {\n      flip(index);\n      moveCount++;\n    }\n  };\n\n  const screenClickPos = [];\n  const worldClickPos = [];\n  const devicePixelRatio = window.devicePixelRatio || 1;\n  inputHandler.addEventListener(\"touchStart\", (x, y) => {\n    screenClickPos[0] = x * devicePixelRatio;\n    screenClickPos[1] = y * devicePixelRatio;\n    camera.unprojectVector2(worldClickPos, screenClickPos);\n\n    for (let i = 0; i < displayPos.length; i++) {\n      const [x, y] = worldClickPos;\n      const dPos = displayPos[i];\n      if (\n        x >= dPos.x &&\n        x <= dPos.x + size &&\n        y >= dPos.y &&\n        y <= dPos.y + size\n      ) {\n        click(i);\n        break;\n      }\n    }\n  });\n\n  let running = true;\n  let onFinish;\n\n  const stop = () => {\n    running = false;\n    inputHandler.cleanup();\n  };\n\n  const finishGame = () => {\n    alert(`You finished the game in ${moveCount} moves!`);\n    stop();\n    onFinish && onFinish();\n  };\n\n  const TRANSITION_SPEED = 2 / 0.2;\n\n  const processEffect = delta => {\n    if (flipBack) {\n      flipBackTime = Math.max(0, flipBackTime - delta);\n      if (flipBackTime === 0 && flipped.length === 2) {\n        for (let i of flipped) {\n          states[i] = false;\n        }\n        flipped.length = 0;\n        flipBack = false;\n      }\n    }\n    if (flyAway) {\n      flyAwayTime = Math.max(0, flyAwayTime - delta);\n      if (flyAwayTime === 0 && flipped.length === 2) {\n        for (let i of flipped) {\n          solved[i] = true;\n        }\n        flipped.length = 0;\n        flyAway = false;\n      }\n    }\n\n    for (let i = 0; i < scales.length; i++) {\n      if (types[i] === undefined) {\n        continue;\n      }\n      const isSolved = solved[i];\n      if (isSolved) {\n        const currentOffset = offsets[i];\n        if (currentOffset < 1) {\n          offsets[i] = currentOffset + TRANSITION_SPEED * delta;\n        } else {\n          types[i] = undefined;\n        }\n      }\n\n      const currentState = states[i];\n      const currentScale = scales[i];\n      if (currentState && currentScale < 1) {\n        scales[i] = Math.min(1, currentScale + TRANSITION_SPEED * delta);\n      }\n      if (!currentState && currentScale > -1) {\n        scales[i] = Math.max(-1, currentScale - TRANSITION_SPEED * delta);\n      }\n    }\n  };\n\n  const shadow = atlas.findRegion(\"shadow\");\n  const items = atlas.findRegions(\"item\");\n  const back = atlas.findRegion(\"back\");\n\n  const [clearR, clearG, clearB] = config.backgroundColor;\n  gl.clearColor(clearR, clearG, clearB, 1);\n\n  const render = delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    processEffect(delta);\n\n    batch.setProjection(camera.combined);\n    batch.begin();\n\n    if (bg) {\n      batch.draw(bg, offsetX, 0, drawWidth, worldHeight);\n    }\n\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type === undefined) continue;\n\n      const { x, y } = displayPos[i];\n      const scale = scales[i];\n      const off = offsets[i];\n\n      shadow.draw(\n        batch,\n        x + shadowDistance,\n        y + shadowDistance,\n        size,\n        size,\n        size / 2,\n        size / 2,\n        0,\n        Math.abs(scale) * (1 - off),\n        1 - off\n      );\n      if (scale > 0) {\n        items[type].draw(\n          batch,\n          x,\n          y,\n          size,\n          size,\n          size / 2,\n          size / 2,\n          0,\n          Math.abs(scale) * (1 - off),\n          1 - off\n        );\n      } else {\n        back.draw(batch, x, y, size, size, size / 2, 0, 0, Math.abs(scale));\n      }\n    }\n    batch.end();\n\n    let finish = true;\n    for (let isSolved of solved) {\n      if (!isSolved) {\n        finish = false;\n        break;\n      }\n    }\n    if (finish) {\n      finishGame();\n    }\n  };\n\n  let lastUpdate = Date.now();\n  const loop = () => {\n    const delta = (Date.now() - lastUpdate) / 1000;\n    render(delta);\n    lastUpdate = Date.now();\n\n    if (running) {\n      requestAnimationFrame(loop);\n    }\n  };\n\n  loop();\n\n  return {\n    stop,\n    setOnFinish: handler => (onFinish = handler)\n  };\n};\n\nexport default init;\n","import \"./index.css\";\nimport init from \"./game/init\";\n\nfunction resize(canvas) {\n  const devicePixelRatio = window.devicePixelRatio || 1;\n\n  const displayWidth = canvas.clientWidth * devicePixelRatio;\n  const displayHeight = canvas.clientHeight * devicePixelRatio;\n\n  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n}\n\nconst canvas = document.getElementById(\"mainCanvas\");\nresize(canvas);\n\nconst gl = canvas.getContext(\"webgl\", { antialias: true });\nconst startNewGame = async () => {\n  const game = await init(gl, canvas.width, canvas.height, canvas);\n  game.setOnFinish(startNewGame);\n};\n\nstartNewGame();\n"],"sourceRoot":""}